MODULE FUTF_ASSERTIONS
    USE FUTF_SUITE, ONLY: FUTF_PASSED, FUTF_EXIT_CODE, &
            REGISTER_PASSED, REGISTER_FAILED, INFO_STRINGS
    USE FUTF_UTILITIES, ONLY: APPEND_CHAR
    
    IMPLICIT NONE

    CHARACTER(LEN=300), PRIVATE :: INFO

    INTERFACE ASSERT_EQUAL
        MODULE PROCEDURE ASSERT_EQUAL_INT_1BYTE
        MODULE PROCEDURE ASSERT_EQUAL_INT_2BYTE
        MODULE PROCEDURE ASSERT_EQUAL_INT_4BYTE
        MODULE PROCEDURE ASSERT_EQUAL_INT_8BYTE
        MODULE PROCEDURE ASSERT_EQUAL_INT_1BYTE_ARR
        MODULE PROCEDURE ASSERT_EQUAL_INT_2BYTE_ARR
        MODULE PROCEDURE ASSERT_EQUAL_INT_4BYTE_ARR
        MODULE PROCEDURE ASSERT_EQUAL_INT_8BYTE_ARR
        MODULE PROCEDURE ASSERT_EQUAL_LOGICAL
        MODULE PROCEDURE ASSERT_EQUAL_REAL_8BYTE
        MODULE PROCEDURE ASSERT_EQUAL_REAL_4BYTE
        MODULE PROCEDURE ASSERT_EQUAL_REAL_8BYTE_ARR
        MODULE PROCEDURE ASSERT_EQUAL_REAL_4BYTE_ARR
        MODULE PROCEDURE ASSERT_EQUAL_COMPLEX
        MODULE PROCEDURE ASSERT_EQUAL_CHAR
    END INTERFACE ASSERT_EQUAL

    INTERFACE ASSERT_ALMOST_EQUAL
        MODULE PROCEDURE ASSERT_ALMOST_EQUAL_INT_1BYTE
        MODULE PROCEDURE ASSERT_ALMOST_EQUAL_INT_2BYTE
        MODULE PROCEDURE ASSERT_ALMOST_EQUAL_INT_4BYTE
        MODULE PROCEDURE ASSERT_ALMOST_EQUAL_INT_8BYTE
        MODULE PROCEDURE ASSERT_ALMOST_EQUAL_REAL_8BYTE
        MODULE PROCEDURE ASSERT_ALMOST_EQUAL_REAL_4BYTE
    END INTERFACE ASSERT_ALMOST_EQUAL

    INTERFACE ASSERT_NOT_EQUAL
        MODULE PROCEDURE ASSERT_NOT_EQUAL_INT_1BYTE
        MODULE PROCEDURE ASSERT_NOT_EQUAL_INT_2BYTE
        MODULE PROCEDURE ASSERT_NOT_EQUAL_INT_4BYTE
        MODULE PROCEDURE ASSERT_NOT_EQUAL_INT_8BYTE
        MODULE PROCEDURE ASSERT_NOT_EQUAL_LOGICAL
        MODULE PROCEDURE ASSERT_NOT_EQUAL_REAL_8BYTE
        MODULE PROCEDURE ASSERT_NOT_EQUAL_REAL_4BYTE
        MODULE PROCEDURE ASSERT_NOT_EQUAL_COMPLEX
        MODULE PROCEDURE ASSERT_NOT_EQUAL_CHAR
    END INTERFACE ASSERT_NOT_EQUAL

    INTERFACE ASSERT_LESS_THAN
        MODULE PROCEDURE ASSERT_LESS_THAN_INT_1BYTE
        MODULE PROCEDURE ASSERT_LESS_THAN_INT_2BYTE
        MODULE PROCEDURE ASSERT_LESS_THAN_INT_4BYTE
        MODULE PROCEDURE ASSERT_LESS_THAN_INT_8BYTE
        MODULE PROCEDURE ASSERT_LESS_THAN_REAL_8BYTE
        MODULE PROCEDURE ASSERT_LESS_THAN_REAL_4BYTE
    END INTERFACE ASSERT_LESS_THAN

    INTERFACE ASSERT_LESS_THAN_EQUAL
        MODULE PROCEDURE ASSERT_LESS_THAN_EQUAL_INT_1BYTE
        MODULE PROCEDURE ASSERT_LESS_THAN_EQUAL_INT_2BYTE
        MODULE PROCEDURE ASSERT_LESS_THAN_EQUAL_INT_4BYTE
        MODULE PROCEDURE ASSERT_LESS_THAN_EQUAL_INT_8BYTE
        MODULE PROCEDURE ASSERT_LESS_THAN_EQUAL_REAL_8BYTE
        MODULE PROCEDURE ASSERT_LESS_THAN_EQUAL_REAL_4BYTE
    END INTERFACE ASSERT_LESS_THAN_EQUAL

    INTERFACE ASSERT_GREATER_THAN
        MODULE PROCEDURE ASSERT_GREATER_THAN_INT_1BYTE
        MODULE PROCEDURE ASSERT_GREATER_THAN_INT_2BYTE
        MODULE PROCEDURE ASSERT_GREATER_THAN_INT_4BYTE
        MODULE PROCEDURE ASSERT_GREATER_THAN_INT_8BYTE
        MODULE PROCEDURE ASSERT_GREATER_THAN_REAL_8BYTE
        MODULE PROCEDURE ASSERT_GREATER_THAN_REAL_4BYTE
    END INTERFACE ASSERT_GREATER_THAN

    INTERFACE ASSERT_GREATER_THAN_EQUAL
        MODULE PROCEDURE ASSERT_GREATER_THAN_EQUAL_INT_1BYTE
        MODULE PROCEDURE ASSERT_GREATER_THAN_EQUAL_INT_2BYTE
        MODULE PROCEDURE ASSERT_GREATER_THAN_EQUAL_INT_4BYTE
        MODULE PROCEDURE ASSERT_GREATER_THAN_EQUAL_INT_8BYTE
        MODULE PROCEDURE ASSERT_GREATER_THAN_EQUAL_REAL_8BYTE
        MODULE PROCEDURE ASSERT_GREATER_THAN_EQUAL_REAL_4BYTE
    END INTERFACE ASSERT_GREATER_THAN_EQUAL

    INTERFACE ASSERT_IS_REAL
        MODULE PROCEDURE ASSERT_IS_REAL_INT_1BYTE
        MODULE PROCEDURE ASSERT_IS_REAL_INT_2BYTE
        MODULE PROCEDURE ASSERT_IS_REAL_INT_4BYTE
        MODULE PROCEDURE ASSERT_IS_REAL_INT_8BYTE
        MODULE PROCEDURE ASSERT_IS_REAL_REAL_8BYTE
        MODULE PROCEDURE ASSERT_IS_REAL_REAL_4BYTE
        MODULE PROCEDURE ASSERT_IS_REAL_COMPLEX
        MODULE PROCEDURE ASSERT_IS_REAL_CHAR
        MODULE PROCEDURE ASSERT_IS_REAL_BOOL
    END INTERFACE ASSERT_IS_REAL
    
    CONTAINS

    !-------------------------------------------------------------------------!
    !                                                                         !
    !                          COMPARISON OPERATIONS                          !
    !                                                                         !
    !-------------------------------------------------------------------------!

    !--------------------- EQUIVALENCE: VAR_1 == VAR_2 -----------------------!

    ! ============================= INTEGER ================================= !
    ! ****************************** SINGLE ********************************* !

    ! - INTEGER(1) SINGLE
    SUBROUTINE ASSERT_EQUAL_INT_1BYTE(INT_1, INT_2)
        INTEGER(1), INTENT(IN) :: INT_1, INT_2
        IF(INT_1 == INT_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_EQUAL: ", INT_1, " == ", INT_2 
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_EQUAL: ", INT_1, " != ", INT_2 
        END IF   
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_EQUAL_INT_1BYTE

    ! - INTEGER(2) SINGLE
    SUBROUTINE ASSERT_EQUAL_INT_2BYTE(INT_1, INT_2)
        INTEGER(2), INTENT(IN) :: INT_1, INT_2

        IF(INT_1 == INT_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_EQUAL: ", INT_1, " == ", INT_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_EQUAL: ", INT_1, " != ", INT_2 
        END IF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_EQUAL_INT_2BYTE

    ! - INTEGER(4) SINGLE
    SUBROUTINE ASSERT_EQUAL_INT_4BYTE(INT_1, INT_2)
        INTEGER(4), INTENT(IN) :: INT_1, INT_2

        IF(INT_1 == INT_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_EQUAL: ", INT_1, " == ", INT_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_EQUAL: ", INT_1, " != ", INT_2 
        END IF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_EQUAL_INT_4BYTE

    ! - INTEGER(8) SINGLE
    SUBROUTINE ASSERT_EQUAL_INT_8BYTE(INT_1, INT_2)
        INTEGER(8), INTENT(IN) :: INT_1, INT_2

        IF(INT_1 == INT_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_EQUAL: ", INT_1, " == ", INT_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_EQUAL: ", INT_1, " != ", INT_2 
        END IF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_EQUAL_INT_8BYTE

    ! ******************************* ARRAY ********************************* !

    ! - INTEGER(1) ARRAY
    SUBROUTINE ASSERT_EQUAL_INT_1BYTE_ARR(INT_1, INT_2)
        INTEGER(1), DIMENSION(:), INTENT(IN) :: INT_1, INT_2
        INTEGER :: I
        LOGICAL :: COMPARE 
        
        COMPARE = .TRUE.

        IF(SIZE(INT_1) /= SIZE(INT_2)) THEN
            WRITE(INFO, '(A, I0, A, I0)') "UNMATCHED ARRAY SIZE: ", SIZE(INT_1), " != ", SIZE(INT_2)
            INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
            RETURN
        ELSE
            DO I=1, SIZE(INT_1)
                IF(INT_1(I) /= INT_2(I)) THEN
                    COMPARE = .FALSE.
                    EXIT
                ENDIF
            ENDDO
        ENDIF

        IF(COMPARE) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, *) "ASSERT_EQUAL: ", INT_1, " == ", INT_2 
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, *) "ASSERT_EQUAL: ", INT_1, " != ", INT_2 
        END IF   
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_EQUAL_INT_1BYTE_ARR

    ! - INTEGER(2) ARRAY
    SUBROUTINE ASSERT_EQUAL_INT_2BYTE_ARR(INT_1, INT_2)
        INTEGER(2), DIMENSION(:), INTENT(IN) :: INT_1, INT_2

        INTEGER :: I
        LOGICAL :: COMPARE 
        
        COMPARE = .TRUE.

        IF(SIZE(INT_1) /= SIZE(INT_2)) THEN
            WRITE(INFO, '(A, I0, A, I0)') "UNMATCHED ARRAY SIZE: ", SIZE(INT_1), " != ", SIZE(INT_2)
            INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
            RETURN
        ELSE
            DO I=1, SIZE(INT_1)
                IF(INT_1(I) /= INT_2(I)) THEN
                    COMPARE = .FALSE.
                    EXIT
                ENDIF
            ENDDO
        ENDIF

        IF(COMPARE) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, *) "ASSERT_EQUAL: ", INT_1, " == ", INT_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, *) "ASSERT_EQUAL: ", INT_1, " != ", INT_2 
        END IF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_EQUAL_INT_2BYTE_ARR

    ! - INTEGER(4) ARRAY
    SUBROUTINE ASSERT_EQUAL_INT_4BYTE_ARR(INT_1, INT_2)
        INTEGER(4), DIMENSION(:), INTENT(IN) :: INT_1, INT_2

        INTEGER :: I
        LOGICAL :: COMPARE 
        
        COMPARE = .TRUE.

        IF(SIZE(INT_1) /= SIZE(INT_2)) THEN
            WRITE(INFO, '(A, I0, A, I0)') "UNMATCHED ARRAY SIZE: ", SIZE(INT_1), " != ", SIZE(INT_2)
            INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
            RETURN
        ELSE
            DO I=1, SIZE(INT_1)
                IF(INT_1(I) /= INT_2(I)) THEN
                    COMPARE = .FALSE.
                    EXIT
                ENDIF
            ENDDO
        ENDIF

        IF(COMPARE) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, *) "ASSERT_EQUAL: ", INT_1, " == ", INT_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, *) "ASSERT_EQUAL: ", INT_1, " != ", INT_2
        END IF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_EQUAL_INT_4BYTE_ARR

    ! - INTEGER(8) ARRAY
    SUBROUTINE ASSERT_EQUAL_INT_8BYTE_ARR(INT_1, INT_2)
        INTEGER(8), DIMENSION(:), INTENT(IN) :: INT_1, INT_2

        INTEGER :: I
        LOGICAL :: COMPARE 
        
        COMPARE = .TRUE.

        IF(SIZE(INT_1) /= SIZE(INT_2)) THEN
            WRITE(INFO, '(A, I0, A, I0)') "UNMATCHED ARRAY SIZE: ", SIZE(INT_1), " != ", SIZE(INT_2)
            INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
            RETURN
        ELSE
            DO I=1, SIZE(INT_1)
                IF(INT_1(I) /= INT_2(I)) THEN
                    COMPARE = .FALSE.
                    EXIT
                ENDIF
            ENDDO
        ENDIF

        IF(COMPARE) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, *) "ASSERT_EQUAL: ", INT_1, " == ", INT_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, *) "ASSERT_EQUAL: ", INT_1, " != ", INT_2 
        END IF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_EQUAL_INT_8BYTE_ARR

    ! =============================== REAL ================================== !
    ! ****************************** SINGLE ********************************* !
    ! - REAL(8)
    SUBROUTINE ASSERT_EQUAL_REAL_8BYTE(REAL_1, REAL_2)
        REAL(8), INTENT(IN) :: REAL_1, REAL_2

        IF(REAL_1 == REAL_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, F0.5, A, F0.5)') "ASSERT_EQUAL: ", REAL_1, " == ", REAL_2 
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, F0.5, A, F0.5)') "ASSERT_EQUAL: ", REAL_1, " != ", REAL_2 
        END IF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_EQUAL_REAL_8BYTE

    ! - REAL(4)
    SUBROUTINE ASSERT_EQUAL_REAL_4BYTE(REAL_1, REAL_2)
        REAL(4), INTENT(IN) :: REAL_1, REAL_2

        IF(REAL_1 == REAL_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, F0.5, A, F0.5)') "ASSERT_EQUAL: ", REAL_1, " == ", REAL_2 
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, F0.5, A, F0.5)') "ASSERT_EQUAL: ", REAL_1, " != ", REAL_2 
        END IF   
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_EQUAL_REAL_4BYTE

    ! ******************************* ARRAY ********************************* !
   
    SUBROUTINE ASSERT_EQUAL_REAL_4BYTE_ARR(REAL_1, REAL_2)
        REAL(4), DIMENSION(:), INTENT(IN) :: REAL_1, REAL_2

        INTEGER :: I
        LOGICAL :: COMPARE 
        CHARACTER(LEN=100) :: FORMAT_STR

        COMPARE = .TRUE.

        IF(SIZE(REAL_1) /= SIZE(REAL_2)) THEN
            WRITE(INFO, '(A, I0, A, I0)') "UNMATCHED ARRAY SIZE: ", SIZE(REAL_1), " != ", SIZE(REAL_2)
            INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
            RETURN
        ELSE
            DO I=1, SIZE(REAL_1)
                IF(REAL_1(I) /= REAL_2(I)) THEN
                    COMPARE = .FALSE.
                    EXIT
                ENDIF
            ENDDO
        ENDIF

        IF(COMPARE) THEN
            CALL REGISTER_PASSED
            WRITE(FORMAT_STR, '("(''ASSERT_EQUAL:'', ", I4, "(X, F0.5), '' =='', ", I4, "(X, F0.5))")') SIZE(REAL_1), SIZE(REAL_2)
            WRITE(INFO, FORMAT_STR) REAL_1, REAL_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(FORMAT_STR, '("(''ASSERT_EQUAL:'', ", I4, "(X, F0.5), '' !='', ", I4, "(X, F0.5))")') SIZE(REAL_1), SIZE(REAL_2)
            WRITE(INFO, FORMAT_STR) REAL_1, REAL_2
        END IF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_EQUAL_REAL_4BYTE_ARR

    SUBROUTINE ASSERT_EQUAL_REAL_8BYTE_ARR(REAL_1, REAL_2)
        REAL(8), DIMENSION(:), INTENT(IN) :: REAL_1, REAL_2

        INTEGER :: I
        LOGICAL :: COMPARE 
        
        CHARACTER(LEN=100) :: FORMAT_STR

        COMPARE = .TRUE.

        IF(SIZE(REAL_1) /= SIZE(REAL_2)) THEN
            WRITE(INFO, '(A, I0, A, I0)') "UNMATCHED ARRAY SIZE: ", SIZE(REAL_1), " != ", SIZE(REAL_2)
            INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
            RETURN
        ELSE
            DO I=1, SIZE(REAL_1)
                IF(REAL_1(I) /= REAL_2(I)) THEN
                    COMPARE = .FALSE.
                    EXIT
                ENDIF
            ENDDO
        ENDIF

        IF(COMPARE) THEN
            CALL REGISTER_PASSED
            WRITE(FORMAT_STR, '("(''ASSERT_EQUAL:'', ", I4, "(X, F0.5), '' =='', ", I4, "(X, F0.5))")') SIZE(REAL_1), SIZE(REAL_2)
            WRITE(INFO, FORMAT_STR) REAL_1, REAL_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(FORMAT_STR, '("(''ASSERT_EQUAL:'', ", I4, "(X, F0.5), '' !='', ", I4, "(X, F0.5))")') SIZE(REAL_1), SIZE(REAL_2)
            WRITE(INFO, FORMAT_STR) REAL_1, REAL_2
        END IF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_EQUAL_REAL_8BYTE_ARR

    ! - COMPLEX
    SUBROUTINE ASSERT_EQUAL_COMPLEX(COMP_1, COMP_2)
        COMPLEX, INTENT(IN) :: COMP_1, COMP_2

        IF(COMP_1 == COMP_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, F0.5, A, F0.5, A, F0.5, A, F0.5, A)') "ASSERT_EQUAL: ", REAL(COMP_1), " &
            &+ ", AIMAG(COMP_1), "I == ", REAL(COMP_2), " + ", AIMAG(COMP_2), "I"
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, F0.5, A, F0.5, A, F0.5, A, F0.5, A)') "ASSERT_EQUAL: ", REAL(COMP_1), " &
            &+ ", AIMAG(COMP_1), "I != ", REAL(COMP_2), " + ", AIMAG(COMP_2), "I"
        END IF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_EQUAL_COMPLEX

    ! - LOGICAL
    SUBROUTINE ASSERT_EQUAL_LOGICAL(BOOL_1, BOOL_2)
        LOGICAL, INTENT(IN) :: BOOL_1, BOOL_2

        IF(BOOL_1 .EQV. BOOL_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, L, A, L)') "ASSERT_EQUAL: ", BOOL_1, " == ", BOOL_2 
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, L, A, L)') "ASSERT_EQUAL: ", BOOL_1, " != ", BOOL_2 
        END IF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))   
    END SUBROUTINE ASSERT_EQUAL_LOGICAL

    ! - CHARACTER
    SUBROUTINE ASSERT_EQUAL_CHAR(CHAR_1, CHAR_2)
        CHARACTER, INTENT(IN) :: CHAR_1, CHAR_2

        IF(CHAR_1 == CHAR_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, A, A, A)') "ASSERT_EQUAL: ", CHAR_1, " == ", CHAR_2 
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, A, A, A)') "ASSERT_EQUAL: ", CHAR_1, " != ", CHAR_2 
        END IF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))   
    END SUBROUTINE ASSERT_EQUAL_CHAR
    
    SUBROUTINE ASSERT_ALMOST_EQUAL_INT_1BYTE(INT_1, INT_2, REL_TOL)
        INTEGER(1), INTENT(IN) :: INT_1, INT_2
        REAL(8), OPTIONAL :: REL_TOL

        REAL(8) :: TOLERANCE
        LOGICAL PASSES

        IF(PRESENT(REL_TOL)) THEN
            TOLERANCE = REL_TOL
        ELSE
            TOLERANCE = 1D-9
        ENDIF

        PASSES = .FALSE.

        IF(TOLERANCE > 1) THEN
            PASSES = 100*ABS(1D0*INT_1-INT_2)/INT_1 <= TOLERANCE
        ELSE
            PASSES = ABS(1D0*INT_1-INT_2)/INT_1 <= TOLERANCE
        ENDIF

        IF(PASSES) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0, A, F0.5)') "ASSERT_ALMOST_EQUAL: ABS(", INT_1, " - ", INT_2, ") < ", TOLERANCE
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0, A, F0.5)') "ASSERT_ALMOST_EQUAL: ABS(", INT_1, " - ", INT_2, ") > ", TOLERANCE
        ENDIF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_ALMOST_EQUAL_INT_1BYTE

    SUBROUTINE ASSERT_ALMOST_EQUAL_INT_2BYTE(INT_1, INT_2, REL_TOL)
        INTEGER(2), INTENT(IN) :: INT_1, INT_2
        REAL(8), OPTIONAL :: REL_TOL

        REAL(8) :: TOLERANCE
        LOGICAL PASSES

        IF(PRESENT(REL_TOL)) THEN
            TOLERANCE = REL_TOL
        ELSE
            TOLERANCE = 1D-9
        ENDIF

        PASSES = .FALSE.

        IF(TOLERANCE > 1) THEN
            PASSES = 100*ABS(1D0*INT_1-INT_2)/INT_1 <= TOLERANCE
        ELSE
            PASSES = ABS(1D0*INT_1-INT_2)/INT_1 <= TOLERANCE
        ENDIF

        IF(PASSES) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0, A, F0.5)') "ASSERT_ALMOST_EQUAL: ABS(", INT_1, " - ", INT_2, ") < ", TOLERANCE
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0, A, F0.5)') "ASSERT_ALMOST_EQUAL: ABS(", INT_1, " - ", INT_2, ") > ", TOLERANCE
        ENDIF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_ALMOST_EQUAL_INT_2BYTE

    SUBROUTINE ASSERT_ALMOST_EQUAL_INT_4BYTE(INT_1, INT_2, REL_TOL)
        INTEGER(4), INTENT(IN) :: INT_1, INT_2
        REAL(8), OPTIONAL :: REL_TOL

        REAL(8) :: TOLERANCE
        LOGICAL PASSES

        IF(PRESENT(REL_TOL)) THEN
            TOLERANCE = REL_TOL
        ELSE
            TOLERANCE = 1D-9
        ENDIF

        PASSES = .FALSE.

        IF(TOLERANCE > 1) THEN
            PASSES = 100*ABS(1D0*INT_1-INT_2)/INT_1 <= TOLERANCE
        ELSE
            PASSES = ABS(1D0*INT_1-INT_2)/INT_1 <= TOLERANCE
        ENDIF

        IF(PASSES) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0, A, F0.5)') "ASSERT_ALMOST_EQUAL: ABS(", INT_1, " - ", INT_2, ") < ", TOLERANCE
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0, A, F0.5)') "ASSERT_ALMOST_EQUAL: ABS(", INT_1, " - ", INT_2, ") > ", TOLERANCE
        ENDIF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_ALMOST_EQUAL_INT_4BYTE

    SUBROUTINE ASSERT_ALMOST_EQUAL_INT_8BYTE(INT_1, INT_2, REL_TOL)
        INTEGER(8), INTENT(IN) :: INT_1, INT_2
        REAL(8), OPTIONAL :: REL_TOL

        REAL(8) :: TOLERANCE
        LOGICAL PASSES

        IF(PRESENT(REL_TOL)) THEN
            TOLERANCE = REL_TOL
        ELSE
            TOLERANCE = 1D-9
        ENDIF

        PASSES = .FALSE.

        IF(TOLERANCE > 1) THEN
            PASSES = 100*ABS(1D0*INT_1-INT_2)/INT_1 <= TOLERANCE
        ELSE
            PASSES = ABS(1D0*INT_1-INT_2)/INT_1 <= TOLERANCE
        ENDIF

        IF(PASSES) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0, A, F0.5)') "ASSERT_ALMOST_EQUAL: ABS(", INT_1, " - ", INT_2, ") < ", TOLERANCE
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0, A, F0.5)') "ASSERT_ALMOST_EQUAL: ABS(", INT_1, " - ", INT_2, ") > ", TOLERANCE
        ENDIF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_ALMOST_EQUAL_INT_8BYTE

    SUBROUTINE ASSERT_ALMOST_EQUAL_REAL_8BYTE(REAL_1, REAL_2, REL_TOL)
        REAL(8), INTENT(IN) :: REAL_1, REAL_2
        REAL(8), OPTIONAL :: REL_TOL

        REAL(8) :: TOLERANCE
        LOGICAL PASSES

        IF(PRESENT(REL_TOL)) THEN
            TOLERANCE = REL_TOL
        ELSE
            TOLERANCE = 1D-9
        ENDIF

        PASSES = .FALSE.

        IF(TOLERANCE > 1) THEN
            PASSES = 100*ABS(REAL_1-REAL_2)/REAL_1 <= TOLERANCE
        ELSE
            PASSES = ABS(REAL_1-REAL_2)/REAL_1 <= TOLERANCE
        ENDIF

        IF(PASSES) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, F0.5, A, F0.5, A, F0.5)') "ASSERT_ALMOST_EQUAL: ABS(", REAL_1, " - ", REAL_2, ") < ", TOLERANCE
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, F0.5, A, F0.5, A, F0.5)') "ASSERT_ALMOST_EQUAL: ABS(", REAL_1, " - ", REAL_2, ") > ", TOLERANCE
        ENDIF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_ALMOST_EQUAL_REAL_8BYTE

    SUBROUTINE ASSERT_ALMOST_EQUAL_REAL_4BYTE(REAL_1, REAL_2, REL_TOL)
        REAL(4), INTENT(IN) :: REAL_1, REAL_2
        REAL(4), OPTIONAL :: REL_TOL

        REAL(4) :: TOLERANCE
        LOGICAL PASSES

        IF(PRESENT(REL_TOL)) THEN
            TOLERANCE = REL_TOL
        ELSE
            TOLERANCE = 1E-9
        ENDIF

        PASSES = .FALSE.

        IF(TOLERANCE > 1) THEN
            PASSES = 100*ABS(REAL_1-REAL_2)/REAL_1 <= TOLERANCE
        ELSE
            PASSES = ABS(REAL_1-REAL_2)/REAL_1 <= TOLERANCE
        ENDIF

        IF(PASSES) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, F0.5, A, F0.5, A, F0.5)') "ASSERT_ALMOST_EQUAL: ABS(", REAL_1, " - ", REAL_2, ") < ", TOLERANCE
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, F0.5, A, F0.5, A, F0.5)') "ASSERT_ALMOST_EQUAL: ABS(", REAL_1, " - ", REAL_2, ") > ", TOLERANCE
        ENDIF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_ALMOST_EQUAL_REAL_4BYTE

    SUBROUTINE ASSERT_TRUE(STATEMENT)
        LOGICAL, INTENT(IN) :: STATEMENT

        IF(STATEMENT) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A)') "STATEMENT RETURNED TRUE"
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A)') "STATEMENT RETURNED FALSE"
        ENDIF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_TRUE

    SUBROUTINE ASSERT_FALSE(STATEMENT)
        LOGICAL, INTENT(IN) :: STATEMENT

        IF(.NOT. STATEMENT) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A)') "STATEMENT RETURNED FALSE"
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A)') "STATEMENT RETURNED TRUE"
        ENDIF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_FALSE

    SUBROUTINE ASSERT_NOT_EQUAL_INT_1BYTE(INT_1, INT_2)
        INTEGER(1), INTENT(IN) :: INT_1, INT_2      

        IF(INT_1 /= INT_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_NOT_EQUAL: ", INT_1, " != ", INT_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_NOT_EQUAL: ", INT_1, " == ", INT_2
        END IF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_NOT_EQUAL_INT_1BYTE

    SUBROUTINE ASSERT_NOT_EQUAL_INT_2BYTE(INT_1, INT_2)
        INTEGER(2), INTENT(IN) :: INT_1, INT_2      

        IF(INT_1 /= INT_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_NOT_EQUAL: ", INT_1, " != ", INT_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_NOT_EQUAL: ", INT_1, " == ", INT_2
        END IF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_NOT_EQUAL_INT_2BYTE

    SUBROUTINE ASSERT_NOT_EQUAL_INT_4BYTE(INT_1, INT_2)
        INTEGER(4), INTENT(IN) :: INT_1, INT_2      

        IF(INT_1 /= INT_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_NOT_EQUAL: ", INT_1, " != ", INT_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_NOT_EQUAL: ", INT_1, " == ", INT_2
        END IF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_NOT_EQUAL_INT_4BYTE

    SUBROUTINE ASSERT_NOT_EQUAL_INT_8BYTE(INT_1, INT_2)
        INTEGER(8), INTENT(IN) :: INT_1, INT_2      

        IF(INT_1 /= INT_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_NOT_EQUAL: ", INT_1, " != ", INT_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_NOT_EQUAL: ", INT_1, " == ", INT_2
        END IF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_NOT_EQUAL_INT_8BYTE

    SUBROUTINE ASSERT_NOT_EQUAL_REAL_8BYTE(REAL_1, REAL_2)
        REAL(8), INTENT(IN) :: REAL_1, REAL_2

        IF(REAL_1 /= REAL_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, F0.5, A, F0.5)') "ASSERT_NOT_EQUAL: ", REAL_1, " != ", REAL_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, F0.5, A, F0.5)') "ASSERT_NOT_EQUAL: ", REAL_1, " == ", REAL_2
        END IF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_NOT_EQUAL_REAL_8BYTE

    SUBROUTINE ASSERT_NOT_EQUAL_REAL_4BYTE(REAL_1, REAL_2)
        REAL(4), INTENT(IN) :: REAL_1, REAL_2

        IF(REAL_1 /= REAL_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, F0.5, A, F0.5)') "ASSERT_NOT_EQUAL: ", REAL_1, " != ", REAL_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, F0.5, A, F0.5)') "ASSERT_NOT_EQUAL: ", REAL_1, " == ", REAL_2
        END IF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_NOT_EQUAL_REAL_4BYTE

    SUBROUTINE ASSERT_NOT_EQUAL_LOGICAL(BOOL_1, BOOL_2)
        LOGICAL, INTENT(IN) :: BOOL_1, BOOL_2

        IF(BOOL_1 .NEQV. BOOL_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, L, A, L)') "ASSERT_NOT_EQUAL: ", BOOL_1, " != ", BOOL_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, L, A, L)') "ASSERT_NOT_EQUAL: ", BOOL_1, " == ", BOOL_2
        END IF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_NOT_EQUAL_LOGICAL

    SUBROUTINE ASSERT_NOT_EQUAL_CHAR(CHAR_1, CHAR_2)
        CHARACTER, INTENT(IN) :: CHAR_1, CHAR_2

        IF(CHAR_1 /= CHAR_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, A, A, A)') "ASSERT_NOT_EQUAL: ", CHAR_1, " != ", CHAR_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, A, A, A)') "ASSERT_NOT_EQUAL: ", CHAR_1, " == ", CHAR_2
        END IF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_NOT_EQUAL_CHAR

    SUBROUTINE ASSERT_NOT_EQUAL_COMPLEX(COMP_1, COMP_2)
        COMPLEX, INTENT(IN) :: COMP_1, COMP_2

        IF(COMP_1 /= COMP_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, F0.5, A, F0.5, A, F0.5, A, F0.5, A)') "ASSERT_NOT_EQUAL: ", REAL(COMP_1), " &
            &+ ", AIMAG(COMP_1), "I != ", REAL(COMP_2), " + ", AIMAG(COMP_2), "I"
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, F0.5, A, F0.5, A, F0.5, A, F0.5, A)') "ASSERT_NOT_EQUAL: ", REAL(COMP_1), " &
            &+ ", AIMAG(COMP_1), "I == ", REAL(COMP_2), " + ", AIMAG(COMP_2), "I"
        END IF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_NOT_EQUAL_COMPLEX

    SUBROUTINE ASSERT_GREATER_THAN_INT_1BYTE(INT_1, INT_2)
        INTEGER(1), INTENT(IN) :: INT_1, INT_2      

        IF(INT_1 > INT_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_GREATER_THAN: ", INT_1, " > ", INT_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_GREATER_THAN: ", INT_1, " <= ", INT_2
        END IF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO))
    END SUBROUTINE ASSERT_GREATER_THAN_INT_1BYTE

    SUBROUTINE ASSERT_GREATER_THAN_INT_2BYTE(INT_1, INT_2)
        INTEGER(2), INTENT(IN) :: INT_1, INT_2      

        IF(INT_1 > INT_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_GREATER_THAN: ", INT_1, " > ", INT_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_GREATER_THAN: ", INT_1, " <= ", INT_2
        END IF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_GREATER_THAN_INT_2BYTE

    SUBROUTINE ASSERT_GREATER_THAN_INT_4BYTE(INT_1, INT_2)
        INTEGER(4), INTENT(IN) :: INT_1, INT_2      

        IF(INT_1 > INT_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_GREATER_THAN: ", INT_1, " > ", INT_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_GREATER_THAN: ", INT_1, " <= ", INT_2
        END IF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_GREATER_THAN_INT_4BYTE

    SUBROUTINE ASSERT_GREATER_THAN_INT_8BYTE(INT_1, INT_2)
        INTEGER(8), INTENT(IN) :: INT_1, INT_2      

        IF(INT_1 > INT_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_GREATER_THAN: ", INT_1, " > ", INT_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_GREATER_THAN: ", INT_1, " <= ", INT_2
        END IF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_GREATER_THAN_INT_8BYTE

    SUBROUTINE ASSERT_GREATER_THAN_REAL_4BYTE(REAL_1, REAL_2)
        REAL(4), INTENT(IN) :: REAL_1, REAL_2

        IF(REAL_1 > REAL_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, F0.5, A, F0.5)') "ASSERT_GREATER_THAN: ", REAL_1, " > ", REAL_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, F0.5, A, F0.5)') "ASSERT_GREATER_THAN: ", REAL_1, " <= ", REAL_2
        END IF
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_GREATER_THAN_REAL_4BYTE

    SUBROUTINE ASSERT_GREATER_THAN_REAL_8BYTE(REAL_1, REAL_2)
        REAL(8), INTENT(IN) :: REAL_1, REAL_2

        IF(REAL_1 > REAL_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, F0.5, A, F0.5)') "ASSERT_GREATER_THAN: ", REAL_1, " > ", REAL_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, F0.5, A, F0.5)') "ASSERT_GREATER_THAN: ", REAL_1, " <= ", REAL_2
        END IF   
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_GREATER_THAN_REAL_8BYTE

    SUBROUTINE ASSERT_LESS_THAN_INT_1BYTE(INT_1, INT_2)
        INTEGER(1), INTENT(IN) :: INT_1, INT_2      

        IF(INT_1 < INT_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_LESS_THAN: ", INT_1, " < ", INT_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_LESS_THAN: ", INT_1, " >= ", INT_2
        END IF   
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_LESS_THAN_INT_1BYTE

    SUBROUTINE ASSERT_LESS_THAN_INT_2BYTE(INT_1, INT_2)
        INTEGER(2), INTENT(IN) :: INT_1, INT_2      

        IF(INT_1 < INT_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_LESS_THAN: ", INT_1, " < ", INT_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_LESS_THAN: ", INT_1, " >= ", INT_2
        END IF   
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_LESS_THAN_INT_2BYTE

    SUBROUTINE ASSERT_LESS_THAN_INT_4BYTE(INT_1, INT_2)
        INTEGER(4), INTENT(IN) :: INT_1, INT_2      

        IF(INT_1 < INT_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_LESS_THAN: ", INT_1, " < ", INT_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_LESS_THAN: ", INT_1, " >= ", INT_2
        END IF   
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_LESS_THAN_INT_4BYTE

    SUBROUTINE ASSERT_LESS_THAN_INT_8BYTE(INT_1, INT_2)
        INTEGER(8), INTENT(IN) :: INT_1, INT_2      

        IF(INT_1 < INT_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_LESS_THAN: ", INT_1, " < ", INT_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_LESS_THAN: ", INT_1, " >= ", INT_2
        END IF   
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_LESS_THAN_INT_8BYTE

    SUBROUTINE ASSERT_LESS_THAN_REAL_8BYTE(REAL_1, REAL_2)
        REAL(8), INTENT(IN) :: REAL_1, REAL_2

        IF(REAL_1 < REAL_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, F0.5, A, F0.5)') "ASSERT_LESS_THAN: ", REAL_1, " < ", REAL_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, F0.5, A, F0.5)') "ASSERT_LESS_THAN: ", REAL_1, " >= ", REAL_2
        END IF   
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_LESS_THAN_REAL_8BYTE

    SUBROUTINE ASSERT_LESS_THAN_REAL_4BYTE(REAL_1, REAL_2)
        REAL(4), INTENT(IN) :: REAL_1, REAL_2

        IF(REAL_1 < REAL_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, F0.5, A, F0.5)') "ASSERT_LESS_THAN: ", REAL_1, " < ", REAL_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, F0.5, A, F0.5)') "ASSERT_LESS_THAN: ", REAL_1, " >= ", REAL_2
        END IF   
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_LESS_THAN_REAL_4BYTE

    SUBROUTINE ASSERT_GREATER_THAN_EQUAL_INT_1BYTE(INT_1, INT_2)
        INTEGER(1), INTENT(IN) :: INT_1, INT_2      

        IF(INT_1 >= INT_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_GREATER_THAN_EQUAL: ", INT_1, " >= ", INT_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_GREATER_THAN_EQUAL: ", INT_1, " < ", INT_2
        END IF   
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_GREATER_THAN_EQUAL_INT_1BYTE

    SUBROUTINE ASSERT_GREATER_THAN_EQUAL_INT_2BYTE(INT_1, INT_2)
        INTEGER(2), INTENT(IN) :: INT_1, INT_2      

        IF(INT_1 >= INT_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_GREATER_THAN_EQUAL: ", INT_1, " >= ", INT_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_GREATER_THAN_EQUAL: ", INT_1, " < ", INT_2
        END IF   
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_GREATER_THAN_EQUAL_INT_2BYTE

    SUBROUTINE ASSERT_GREATER_THAN_EQUAL_INT_4BYTE(INT_1, INT_2)
        INTEGER(4), INTENT(IN) :: INT_1, INT_2      

        IF(INT_1 >= INT_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_GREATER_THAN_EQUAL: ", INT_1, " >= ", INT_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_GREATER_THAN_EQUAL: ", INT_1, " < ", INT_2
        END IF   
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_GREATER_THAN_EQUAL_INT_4BYTE

    SUBROUTINE ASSERT_GREATER_THAN_EQUAL_INT_8BYTE(INT_1, INT_2)
        INTEGER(8), INTENT(IN) :: INT_1, INT_2      

        IF(INT_1 >= INT_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_GREATER_THAN_EQUAL: ", INT_1, " >= ", INT_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_GREATER_THAN_EQUAL: ", INT_1, " < ", INT_2
        END IF   
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_GREATER_THAN_EQUAL_INT_8BYTE

    SUBROUTINE ASSERT_GREATER_THAN_EQUAL_REAL_8BYTE(REAL_1, REAL_2)
        REAL(8), INTENT(IN) :: REAL_1, REAL_2      

        IF(REAL_1 >= REAL_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, F0.5, A, F0.5)') "ASSERT_GREATER_THAN_EQUAL: ", REAL_1, " >= ", REAL_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, F0.5, A, F0.5)') "ASSERT_GREATER_THAN_EQUAL: ", REAL_1, " < ", REAL_2
        END IF   
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_GREATER_THAN_EQUAL_REAL_8BYTE

    SUBROUTINE ASSERT_GREATER_THAN_EQUAL_REAL_4BYTE(REAL_1, REAL_2)
        REAL(4), INTENT(IN) :: REAL_1, REAL_2      

        IF(REAL_1 >= REAL_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, F0.5, A, F0.5)') "ASSERT_GREATER_THAN_EQUAL: ", REAL_1, " >= ", REAL_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, F0.5, A, F0.5)') "ASSERT_GREATER_THAN_EQUAL: ", REAL_1, " < ", REAL_2
        END IF   
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_GREATER_THAN_EQUAL_REAL_4BYTE

    SUBROUTINE ASSERT_LESS_THAN_EQUAL_INT_1BYTE(INT_1, INT_2)
        INTEGER(1), INTENT(IN) :: INT_1, INT_2      

        IF(INT_1 <= INT_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_LESS_THAN_EQUAL: ", INT_1, " >= ", INT_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_LESS_THAN_EQUAL: ", INT_1, " < ", INT_2
        END IF   
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_LESS_THAN_EQUAL_INT_1BYTE

    SUBROUTINE ASSERT_LESS_THAN_EQUAL_INT_2BYTE(INT_1, INT_2)
        INTEGER(2), INTENT(IN) :: INT_1, INT_2      

        IF(INT_1 <= INT_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_LESS_THAN_EQUAL: ", INT_1, " >= ", INT_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_LESS_THAN_EQUAL: ", INT_1, " < ", INT_2
        END IF   
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_LESS_THAN_EQUAL_INT_2BYTE

    SUBROUTINE ASSERT_LESS_THAN_EQUAL_INT_4BYTE(INT_1, INT_2)
        INTEGER(4), INTENT(IN) :: INT_1, INT_2      

        IF(INT_1 <= INT_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_LESS_THAN_EQUAL: ", INT_1, " >= ", INT_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_LESS_THAN_EQUAL: ", INT_1, " < ", INT_2
        END IF   
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_LESS_THAN_EQUAL_INT_4BYTE

    SUBROUTINE ASSERT_LESS_THAN_EQUAL_INT_8BYTE(INT_1, INT_2)
        INTEGER(8), INTENT(IN) :: INT_1, INT_2      

        IF(INT_1 <= INT_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_LESS_THAN_EQUAL: ", INT_1, " >= ", INT_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, I0, A, I0)') "ASSERT_LESS_THAN_EQUAL: ", INT_1, " < ", INT_2
        END IF   
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_LESS_THAN_EQUAL_INT_8BYTE

    SUBROUTINE ASSERT_LESS_THAN_EQUAL_REAL_4BYTE(REAL_1, REAL_2)
        REAL(4), INTENT(IN) :: REAL_1, REAL_2

        IF(REAL_1 <= REAL_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, F0.5, A, F0.5)') "ASSERT_LESS_THAN_EQUAL: ", REAL_1, " >= ", REAL_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, F0.5, A, F0.5)') "ASSERT_LESS_THAN_EQUAL: ", REAL_1, " < ", REAL_2
        END IF   
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_LESS_THAN_EQUAL_REAL_4BYTE

    SUBROUTINE ASSERT_LESS_THAN_EQUAL_REAL_8BYTE(REAL_1, REAL_2)
        REAL(8), INTENT(IN) :: REAL_1, REAL_2

        IF(REAL_1 <= REAL_2) THEN
            CALL REGISTER_PASSED
            WRITE(INFO, '(A, F0.5, A, F0.5)') "ASSERT_GREATER_THAN_EQUAL: ", REAL_1, " >= ", REAL_2
        ELSE
            CALL REGISTER_FAILED
            WRITE(INFO, '(A, F0.5, A, F0.5)') "ASSERT_GREATER_THAN_EQUAL: ", REAL_1, " >= ", REAL_2
        END IF   
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_LESS_THAN_EQUAL_REAL_8BYTE

    SUBROUTINE ASSERT_IS_REAL_REAL_4BYTE(REAL_VAR)
        REAL(4), INTENT(IN) :: REAL_VAR
        CALL REGISTER_PASSED
        WRITE(INFO, '(A, F0.5, A)') "ASSERT_IS_REAL: ", REAL_VAR, " (REAL)"
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_IS_REAL_REAL_4BYTE

    SUBROUTINE ASSERT_IS_REAL_REAL_8BYTE(REAL_VAR)
        REAL(8), INTENT(IN) :: REAL_VAR
        CALL REGISTER_PASSED
        WRITE(INFO, '(A, F0.5, A)') "ASSERT_IS_REAL: ", REAL_VAR, " (REAL)"
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_IS_REAL_REAL_8BYTE

    SUBROUTINE ASSERT_IS_REAL_INT_1BYTE(INT_VAR)
        INTEGER(1), INTENT(IN) :: INT_VAR
        CALL REGISTER_FAILED
        WRITE(INFO, '(A, I0, A)') "ASSERT_IS_REAL: ", INT_VAR, " (INT)"
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_IS_REAL_INT_1BYTE

    SUBROUTINE ASSERT_IS_REAL_INT_2BYTE(INT_VAR)
        INTEGER(2), INTENT(IN) :: INT_VAR
        CALL REGISTER_FAILED
        WRITE(INFO, '(A, I0, A)') "ASSERT_IS_REAL: ", INT_VAR, " (INT)"
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_IS_REAL_INT_2BYTE

    SUBROUTINE ASSERT_IS_REAL_INT_4BYTE(INT_VAR)
        INTEGER(4), INTENT(IN) :: INT_VAR
        CALL REGISTER_FAILED
        WRITE(INFO, '(A, I0, A)') "ASSERT_IS_REAL: ", INT_VAR, " (INT)"
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_IS_REAL_INT_4BYTE

    SUBROUTINE ASSERT_IS_REAL_INT_8BYTE(INT_VAR)
        INTEGER(8), INTENT(IN) :: INT_VAR
        CALL REGISTER_FAILED
        WRITE(INFO, '(A, I0, A)') "ASSERT_IS_REAL: ", INT_VAR, " (INT)"
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_IS_REAL_INT_8BYTE

    SUBROUTINE ASSERT_IS_REAL_CHAR(CHAR_VAR)
        CHARACTER(*), INTENT(IN) :: CHAR_VAR
        CALL REGISTER_FAILED
        WRITE(INFO, '(A, A, A)') "ASSERT_IS_REAL: ", CHAR_VAR, " (CHAR)"
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_IS_REAL_CHAR

    SUBROUTINE ASSERT_IS_REAL_BOOL(BOOL_VAR)
        LOGICAL, INTENT(IN) :: BOOL_VAR
        CALL REGISTER_FAILED
        WRITE(INFO, '(A, L, A)') "ASSERT_IS_REAL: ", BOOL_VAR, " (LOGICAL)"
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_IS_REAL_BOOL

    SUBROUTINE ASSERT_IS_REAL_COMPLEX(COMP_VAR)
        COMPLEX, INTENT(IN) :: COMP_VAR
        CALL REGISTER_FAILED
        WRITE(INFO, '(A, F0.5, A, F0.5, A, A)') "ASSERT_NOT_EQUAL: ", REAL(COMP_VAR), " & 
               & + ", AIMAG(COMP_VAR), "I", " (COMPLEX)"
        INFO_STRINGS = APPEND_CHAR(INFO_STRINGS, INFO, LEN(INFO)) 
    END SUBROUTINE ASSERT_IS_REAL_COMPLEX
    
END MODULE
